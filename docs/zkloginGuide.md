Step 1: Generate Ephemeral Key Pair

The ephemeral key pair is used to sign the TransactionBlock

Stored in the browser session. (Session Storage)

Step 2: Fetch JWT (from OpenID Provider)

Required parameters:

$CLIENT_ID (Obtained by applying for OpenID Service.)

$REDIRECT_URL (App Url, configured in OpenID Service)

$NONCE (Generated throughephemeralKeyPair maxEpoch randomness)

*ephemeralKeyPair: Ephemeral key pair generated in the previous step

*maxEpoch: Validity period of the ephemeral key pair

*randomness: Randomness

example: Current Epoch: 41 Assuming the validity period is set to 10 Epochs, then: maxEpoch:51

import { generateRandomness } from '@mysten/zklogin';

// randomness const randomness = generateRandomness(); randomness: 63875590592568235153480153643975403586

import { generateNonce } from "@mysten/zklogin";

// Generate Nonce for acquiring JWT: const nonce = generateNonce( ephemeralKeyPair.getPublicKey(), maxEpoch, randomness );

nonce: sibKtAsXsL8AQg9jvxdQSJN4h9E proceed to sign in with google

Step 3: Decode JWT (needed for assembling zkLogin signature later)

Successfully logged in via Google! UrlQuery: id_token

// id_token Header.Payload.Signature "eyJhbGciOiJSUzI1NiIsImtpZCI6ImJhNjNiNDM2ODM2YTkzOWI3OTViNDEyMmQzZjRkMGQyMjVkMWM3MDAiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiI1NzMxMjAwNzA4NzEtMGs3Z2E2bnM3OWllMGpwZzFlaTZpcDV2amUyb3N0dDYuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiI1NzMxMjAwNzA4NzEtMGs3Z2E2bnM3OWllMGpwZzFlaTZpcDV2amUyb3N0dDYuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMTA1MDM4MjA0OTIyMTQzNzI5MzYiLCJub25jZSI6InNpYkt0QXNYc0w4QVFnOWp2eGRRU0pONGg5RSIsIm5iZiI6MTc1NDQ3MTgxMywiaWF0IjoxNzU0NDcyMTEzLCJleHAiOjE3NTQ0NzU3MTMsImp0aSI6IjgzOTRkODA3MTc4Y2JjYWYxM2JiYmNkYWUyYjYyNmJmYjliNzMwYzcifQ.NN6EwfIW-vPzoxI5Hs1RSRlnGPHS2wxUo6FZzSpcAM7d2XfHMvcIHHN02D1T8TYs9ybu3kvjRT6EV1ybuRMsBADpA7lSg6gvsubQMD9Dnsm6t_HepfpCIo5-4iBEnQZSod5cej994xvMG1XToboyvVw49umO8W6kdGJ10UhRnvirticA1b2ety5cQh4JBKoljcTJ-7iLUVIC8kN06bE_Pw2kwsUEIAg_Cs4ZtrlwqySLXb6sSt7JY6QTNXbRg7r4SpGj3JHVof55cGbrVDAn2nUiNl4fQX9Lqvgq_Gm3evQh_wJRqBjr-6oBwBZDd1815S4cGuKJ9yQBV5X6Ruow2w"

import { JwtPayload, jwtDecode } from "jwt-decode";

const jwtPayload = jwtDecode(id_token); const decodedJwt = jwt_decode(jwtPayload) as JwtPayload; // JWT Payload { "iss": "https://accounts.google.com", "azp": "573120070871-0k7ga6ns79ie0jpg1ei6ip5vje2ostt6.apps.googleusercontent.com", "aud": "573120070871-0k7ga6ns79ie0jpg1ei6ip5vje2ostt6.apps.googleusercontent.com", "sub": "110503820492214372936", "nonce": "sibKtAsXsL8AQg9jvxdQSJN4h9E", "nbf": 1754471813, "iat": 1754472113, "exp": 1754475713, "jti": "8394d807178cbcaf13bbbcdae2b626bfb9b730c7" } iss (issuer)：Issuer

aud (audience)：JWT Consumer (CLIENT_ID)

sub (subject)：Subject (user identifier, unique for each user)

nonce：Signature order (values generated by assembling URL parameters earlier)

nbf (Not Before)：Issued At

iat(Issued At)：Issued Time

exp (expiration time)：Expiration Time

jti (JWT ID)：JWT ID

Step 4: Generate User's Salt

User Salt is used to eliminate the one-to-one correspondence between the OAuth identifier (sub) and the on-chain Sui address, avoiding linking Web2 credentials with Web3 credentials.

Therefore, it is essential to safeguard the Salt. If lost, users won't be able to recover the address generated with the current Salt. Where to Save:

Ask the user to remember (send to user's email)

Store on the client side (browser)

Save in the APP Backend database, corresponding one-to-one with UID

example: User Salt: 4512303876130070085853693928590050493

Step 5: Generate User's Sui Address

The user's Sui address is determined by sub,iss,aud and user_salt together. For the same JWT, sub, iss, and aud will not change with each login.

import { jwtToAddress } from "@mysten/zklogin";

const zkLoginUserAddress = jwtToAddress(jwt, userSalt); example:User Sui Address: 0x8d647686303972d40cd998b3e1381355bd7ee35492d04bbad5076ec5ccd5ef26

Step 6: Fetch ZK Proof (Groth16)

This is the proof (ZK Proof) for the ephemeral key pair, used to demonstrate the validity of the ephemeral key pair.

First, generate the extended ephemeral public key as input for the ZKP.
import { getExtendedEphemeralPublicKey } from "@mysten/zklogin";

const extendedEphemeralPublicKey = getExtendedEphemeralPublicKey( ephemeralKeyPair.getPublicKey() ); example: extendedEphemeralPublicKey:20380528566958652069995450387807043740001514606231197539137107664747056165101 Use the generated extended ephemeral public key (extendedEphemeralPublicKey) to generate ZK Proof. SUI provides a backend service (or you can run a Docker).

const zkProofResult = await axios.post( "https://prover-dev.mystenlabs.com/v1", { jwt: oauthParams?.id_token as string, extendedEphemeralPublicKey: extendedEphemeralPublicKey, maxEpoch: maxEpoch, jwtRandomness: randomness, salt: userSalt, keyClaimName: "sub", }, { headers: { "Content-Type": "application/json", }, } ).data;

const partialZkLoginSignature = zkProofResult as PartialZkLoginSignature

{ "proofPoints": { "a": [ "3972025971281564911626489033274373652282013263696403288676431896105451670447", "16590136125761221092056773642424308008676883523552045289434355850627271887990", "1" ], "b": [ [ "13204821407204208757572009852353844576105931443774393676100166596689947497056", "4012277505684280254843423412670113908174351109324390353487790705671769311652" ], [ "3547269396456379617482971319201053324587302221303183062186529821030484958911", "15986550641256624705476801257889939585620984355787156082605636836268379141032" ], [ "1", "0" ] ], "c": [ "20525664243908701504532189269790932003126320712893953509608225473005995413299", "13954519342744173574130304487152917329911887066221892515207633365487242215540", "1" ] }, "issBase64Details": { "value": "yJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLC", "indexMod4": 1 }, "headerBase64": "eyJhbGciOiJSUzI1NiIsImtpZCI6ImJhNjNiNDM2ODM2YTkzOWI3OTViNDEyMmQzZjRkMGQyMjVkMWM3MDAiLCJ0eXAiOiJKV1QifQ" }

are all these steps implemented?