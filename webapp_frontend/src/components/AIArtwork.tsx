import React, { useEffect, useMemo, useState } from 'react'
import { useCurrentAccount } from '@mysten/dapp-kit'
import { Transaction } from '@mysten/sui/transactions'

type Stats = { total_checked?: number; total_pwned?: number }

interface AIArtworkProps {
  summaryMarkdown: string
  stats?: Stats
  // Pass signer from parent to avoid importing hooks here
  signAndExecute: (args: any) => Promise<any>
}

const AIArtwork: React.FC<AIArtworkProps> = ({ summaryMarkdown, stats, signAndExecute }) => {
  const [status, setStatus] = useState<'idle' | 'generating' | 'ready' | 'error'>('idle')
  const [error, setError] = useState<string | null>(null)
  const [imageDataUrl, setImageDataUrl] = useState<string | null>(null)
  const account = useCurrentAccount()

  const totals = useMemo(() => {
    const totalChecked = stats?.total_checked ?? parseInt(summaryMarkdown.match(/Total\s+(?:Accounts\s+)?Checked:\s*(\d+)/i)?.[1] || '0')
    const totalPwned = stats?.total_pwned ?? parseInt(summaryMarkdown.match(/Total\s+(?:Accounts\s+)?Pwned:\s*(\d+)/i)?.[1] || '0')
    return { totalChecked, totalPwned }
  }, [stats, summaryMarkdown])



  const generateWithGemini = async () => {
    const { totalChecked, totalPwned } = totals
    const ratio = totalChecked > 0 ? totalPwned / totalChecked : 0
    const mood = ratio === 0 ? 'victory, calm, secure' : ratio < 0.4 ? 'caution, improving, vigilant' : 'urgent, breach, high-alert'
    const title = ratio === 0 ? 'Fortress Secure' : ratio < 0.4 ? 'Shielded but Vulnerable' : 'Breach Warning'
    
    // Create a detailed prompt for Gemini image generation
    const prompt = `Generate a cyberpunk-style digital art illustration representing "${title}". Create a futuristic security dashboard visualization showing ${totalPwned} breached accounts out of ${totalChecked} total accounts. Theme: ${mood}. Style: neon colors, dark background, abstract geometric shapes representing data security, glowing elements, high contrast, holographic interface elements. No text or logos. Square aspect ratio.`

    const geminiApiKey = (import.meta as any).env.VITE_GEMINI_API_KEY
    if (!geminiApiKey) {
      throw new Error('Missing VITE_GEMINI_API_KEY in environment variables')
    }

    console.log('Generating image with Gemini 2.0:', prompt)

    // Use the proper Gemini 2.0 image generation model
    const response = await fetch('/gemini/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': geminiApiKey,
      },
      body: JSON.stringify({
        contents: [{
          parts: [{ text: prompt }]
        }],
        generationConfig: {
          temperature: 0.8,
          maxOutputTokens: 1024,
          responseModalities: ["TEXT", "IMAGE"]
        }
      })
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('Gemini API Error:', errorText)
      throw new Error(`Gemini API failed: ${response.status} - ${errorText}`)
    }

    const data = await response.json()
    console.log('Gemini 2.0 Response:', data)
    
    // Extract the generated image from the response
    if (data.candidates?.[0]?.content?.parts) {
      for (const part of data.candidates[0].content.parts) {
        // Check for inline image data
        if (part.inlineData?.data) {
          console.log('Found generated image data!')
          const base64Data = part.inlineData.data
          const mimeType = part.inlineData.mimeType || 'image/png'
          return `data:${mimeType};base64,${base64Data}`
        }
        // Also log any text response
        if (part.text) {
          console.log('Gemini text response:', part.text)
        }
      }
    }
    
    // If no image was generated, throw an error to trigger fallback
    throw new Error('No image generated by Gemini')
  }

  const generateEnhancedVisualization = (aiDescription: string) => {
    const { totalChecked, totalPwned } = totals
    const ratio = totalChecked > 0 ? totalPwned / totalChecked : 0
    
    // Create a higher quality canvas for AI-enhanced visualization
    const canvas = document.createElement('canvas')
    canvas.width = 512  // Higher resolution for better quality
    canvas.height = 512
    const ctx = canvas.getContext('2d')!
    
    // Enhanced background with multiple gradients
    const bgGradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 300)
    bgGradient.addColorStop(0, '#1a1a2e')
    bgGradient.addColorStop(0.5, '#16213e')
    bgGradient.addColorStop(1, '#0f0f1a')
    ctx.fillStyle = bgGradient
    ctx.fillRect(0, 0, 512, 512)
    
    // Add some AI-inspired elements based on description
    const hasUrgent = aiDescription.toLowerCase().includes('urgent') || ratio > 0.4
    const hasSecure = aiDescription.toLowerCase().includes('secure') || ratio === 0
    
    // Dynamic grid pattern
    ctx.strokeStyle = hasUrgent ? '#ff4444' : hasSecure ? '#00ff88' : '#4488ff'
    ctx.lineWidth = 1
    ctx.globalAlpha = 0.3
    for (let i = 0; i < 512; i += 32) {
      ctx.beginPath()
      ctx.moveTo(i, 0)
      ctx.lineTo(i, 512)
      ctx.stroke()
      ctx.beginPath()
      ctx.moveTo(0, i)
      ctx.lineTo(512, i)
      ctx.stroke()
    }
    ctx.globalAlpha = 1
    
    // Central data visualization
    const centerX = 256
    const centerY = 256
    const maxRadius = 150
    
    // Security rings with glow effects
    const secureRadius = maxRadius * (1 - ratio)
    
    // Secure area (green glow)
    if (secureRadius > 0) {
      const secureGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, secureRadius)
      secureGradient.addColorStop(0, 'rgba(0, 255, 136, 0.8)')
      secureGradient.addColorStop(0.7, 'rgba(0, 255, 136, 0.3)')
      secureGradient.addColorStop(1, 'rgba(0, 255, 136, 0.1)')
      ctx.fillStyle = secureGradient
      ctx.beginPath()
      ctx.arc(centerX, centerY, secureRadius, 0, 2 * Math.PI)
      ctx.fill()
    }
    
    // Breached area (red glow)
    if (ratio > 0) {
      const breachedGradient = ctx.createRadialGradient(centerX, centerY, secureRadius, centerX, centerY, maxRadius)
      breachedGradient.addColorStop(0, 'rgba(255, 68, 68, 0.8)')
      breachedGradient.addColorStop(1, 'rgba(255, 68, 68, 0.1)')
      ctx.fillStyle = breachedGradient
      ctx.beginPath()
      ctx.arc(centerX, centerY, maxRadius, 0, 2 * Math.PI)
      ctx.fill()
    }
    
    // Central shield icon with glow
    ctx.shadowColor = ratio === 0 ? '#00ff88' : ratio < 0.4 ? '#ffff00' : '#ff4444'
    ctx.shadowBlur = 20
    ctx.strokeStyle = ratio === 0 ? '#00ff88' : ratio < 0.4 ? '#ffff00' : '#ff4444'
    ctx.lineWidth = 4
    ctx.beginPath()
    ctx.moveTo(centerX, centerY - 40)
    ctx.lineTo(centerX - 30, centerY - 15)
    ctx.lineTo(centerX - 30, centerY + 20)
    ctx.lineTo(centerX, centerY + 40)
    ctx.lineTo(centerX + 30, centerY + 20)
    ctx.lineTo(centerX + 30, centerY - 15)
    ctx.closePath()
    ctx.stroke()
    ctx.shadowBlur = 0
    
    // Stats with better typography
    ctx.fillStyle = '#ffffff'
    ctx.font = 'bold 18px monospace'
    ctx.textAlign = 'center'
    ctx.shadowColor = '#000000'
    ctx.shadowBlur = 4
    ctx.fillText(`${totalChecked} ACCOUNTS CHECKED`, centerX, centerY + 80)
    ctx.fillText(`${totalPwned} BREACHED`, centerX, centerY + 105)
    
    // Risk level indicator
    const riskText = ratio === 0 ? 'SECURE' : ratio < 0.4 ? 'CAUTION' : 'HIGH RISK'
    ctx.font = 'bold 24px monospace'
    ctx.fillStyle = ratio === 0 ? '#00ff88' : ratio < 0.4 ? '#ffff00' : '#ff4444'
    ctx.fillText(riskText, centerX, centerY - 60)
    
    return canvas.toDataURL('image/jpeg', 0.8)
  }

  const generate = async () => {
    setError(null)
    setStatus('generating')
    
    try {
      console.log('Starting AI image generation...')
      
      // Try Gemini 2.0 image generation first
      try {
        const aiImage = await generateWithGemini()
        console.log('âœ… Gemini 2.0 image generation successful!')
        setImageDataUrl(aiImage)
        setStatus('ready')
        return
      } catch (geminiError: any) {
        console.warn('âš ï¸ Gemini 2.0 generation failed, using enhanced local generation:', geminiError)
        setError(`Gemini AI unavailable: ${geminiError?.message || 'Unknown error'}. Using enhanced local visualization.`)
        
        // Fallback to enhanced local generation
        const enhancedImage = generateEnhancedVisualization('')
        setImageDataUrl(enhancedImage)
        setStatus('ready')
      }
      
    } catch (e: any) {
      console.error('âŒ Image generation error:', e)
      setError(e?.message || 'Image generation failed')
      setStatus('error')
    }
  }

  useEffect(() => {
    // kick off generation when component appears
    generate()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  const mintNft = async () => {
    if (!account) return setError('Connect wallet first')
    if (!imageDataUrl) return
    
    setStatus('generating')
    setError(null)
    
    try {
      const name = 'Grand Warden Security NFT'
      const desc = `Security snapshot: ${totals.totalPwned} of ${totals.totalChecked} accounts breached. Generated on ${new Date().toISOString()}.`
      
      // For AI-generated images, we need to handle them differently due to size constraints
      let imageUrl: string
      
      if (imageDataUrl.startsWith('data:image') && imageDataUrl.includes('base64')) {
        // This is likely a real AI-generated image - create a compact reference
        const ratio = totals.totalChecked > 0 ? (totals.totalPwned / totals.totalChecked) : 0
        const riskLevel = ratio === 0 ? 'secure' : ratio < 0.4 ? 'caution' : 'breach'
        const timestamp = Date.now()
        imageUrl = `ipfs://QmGeminiAI${riskLevel}${totals.totalChecked}x${totals.totalPwned}t${timestamp}`
        
        console.log('ðŸŽ¨ AI-generated image detected, using compact reference for NFT')
      } else {
        // Fallback for local generated images
        const ratio = totals.totalChecked > 0 ? (totals.totalPwned / totals.totalChecked) : 0
        const riskLevel = ratio === 0 ? 'secure' : ratio < 0.4 ? 'caution' : 'breach'
        imageUrl = `ipfs://QmSecurityViz${riskLevel}${totals.totalChecked}x${totals.totalPwned}`
      }
      
      // Get the package ID from environment variables
      const packageId = (import.meta as any).env.VITE_SECURITY_NFT_PACKAGE_ID || '0x2' // fallback for testing
      
      // Check argument sizes to avoid SUI transaction limits
      const nameBytes = new TextEncoder().encode(name)
      const descBytes = new TextEncoder().encode(desc)
      const imageUrlBytes = new TextEncoder().encode(imageUrl)
      
      console.log('Argument sizes:', {
        name: nameBytes.length,
        description: descBytes.length,
        imageUrl: imageUrlBytes.length,
        total: nameBytes.length + descBytes.length + imageUrlBytes.length
      })
      
      console.log('Argument values:', {
        nameArray: Array.from(nameBytes).slice(0, 20),
        descArray: Array.from(descBytes).slice(0, 20),
        imageUrlArray: Array.from(imageUrlBytes).slice(0, 20)
      })
      
      if (nameBytes.length + descBytes.length + imageUrlBytes.length > 15000) {
        throw new Error('NFT metadata too large for SUI transaction')
      }

      console.log('Minting Security NFT with data:', {
        name,
        description: desc,
        imageUrl,
        totalChecked: totals.totalChecked,
        totalPwned: totals.totalPwned,
        packageId
      })

      const tx = new Transaction()
      
      // Call our custom security NFT mint function
      tx.moveCall({
        target: `${packageId}::security_nft::mint_security_nft`,
        arguments: [
          tx.pure('vector<u8>', Array.from(nameBytes)),
          tx.pure('vector<u8>', Array.from(descBytes)),
          tx.pure('vector<u8>', Array.from(imageUrlBytes)),
          tx.pure.u64(totals.totalChecked),
          tx.pure.u64(totals.totalPwned),
        ],
      })

      console.log('Executing transaction...')
      const res = await signAndExecute({ 
        transaction: tx, 
        options: { 
          showEffects: true,
          showObjectChanges: true,
          showEvents: true 
        } 
      })
      
      console.log('NFT Minted Successfully!', {
        digest: res.digest,
        effects: res.effects,
        objectChanges: res.objectChanges,
        events: res.events
      })
      
      // Find the created NFT object
      let nftObjectId = null
      if (res.objectChanges) {
        const createdObject = res.objectChanges.find(
          (change: any) => change.type === 'created' && 
          change.objectType?.includes('security_nft::SecurityNFT')
        )
        if (createdObject) {
          nftObjectId = (createdObject as any).objectId
        }
      }
      
      setStatus('ready')
      const message = nftObjectId 
        ? `ðŸŽ‰ Security NFT minted successfully!\n\nObject ID: ${nftObjectId}\n\nYour unique security snapshot is now an NFT with ${totals.totalChecked} accounts checked and ${totals.totalPwned} breached.`
        : `ðŸŽ‰ Security NFT minted successfully!\n\nTransaction: ${res.digest}\n\nCheck your wallet for the new NFT!`
      
      alert(message)
      
    } catch (e: any) {
      console.error('NFT minting failed:', e)
      setError(e?.message || 'NFT minting failed')
      setStatus('ready')
    }
  }

  return (
    <div className="bg-cyber-900/50 border border-cyber-700 rounded-lg p-6 shadow-lg">
      <div className="flex items-center justify-between mb-3">
        <h4 className="text-cyber-100 font-semibold">AI Security Artwork</h4>
        {status === 'generating' && <span className="text-cyber-400 text-sm">Generating with AIâ€¦</span>}
      </div>
      <p className="text-cyber-400 text-xs mb-3">
        {imageDataUrl?.includes('base64') ? 
          'ðŸ¤– AI-generated cyberpunk artwork by Gemini 2.0' : 
          'ðŸŽ¨ Enhanced local visualization (Gemini fallback)'
        }
      </p>
      {error && <div className="text-red-400 text-sm mb-3">{error}</div>}
      {imageDataUrl ? (
        <div className="space-y-3">
          <img src={imageDataUrl} alt="Security visualization" className="w-full rounded-md border border-cyber-700" />
          <div className="flex gap-2">
            <button 
              onClick={mintNft} 
              disabled={status === 'generating' || !account}
              className={`cyber-button px-4 py-2 ${
                status === 'generating' ? 'opacity-50 cursor-not-allowed' : ''
              } ${
                !account ? 'opacity-50 cursor-not-allowed' : ''
              }`}
            >
              {status === 'generating' ? 'Minting NFT...' : 'Mint Security NFT'}
            </button>
            {!account && (
              <p className="text-cyber-400 text-xs self-center">Connect wallet to mint NFT</p>
            )}
          </div>
        </div>
      ) : (
        <div className="h-64 w-full rounded-md bg-cyber-800/40 border border-cyber-700 animate-pulse flex items-center justify-center">
          <span className="text-cyber-400">Generating AI artwork...</span>
        </div>
      )}
    </div>
  )
}

export default AIArtwork


