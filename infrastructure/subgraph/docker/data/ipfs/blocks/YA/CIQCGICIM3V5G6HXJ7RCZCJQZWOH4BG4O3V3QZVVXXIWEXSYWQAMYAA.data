
ƒBûA# Grand Warden Subgraph Schema
# Comprehensive GraphQL schema for indexing all Grand Warden contract events

type User @entity {
  id: ID! # User's Ethereum address
  
  # Vault statistics
  totalVaults: BigInt!
  totalCredentials: BigInt!
  totalWallets: BigInt!
  totalDevices: BigInt!
  
  # Activity tracking
  lastActivity: BigInt!
  createdAt: BigInt!
  
  # Security metrics
  breachAlerts: [BreachAlert!]! @derivedFrom(field: "user")
  securityAlerts: [SecurityAlert!]! @derivedFrom(field: "user")
  
  # Related entities
  vaults: [Vault!]! @derivedFrom(field: "owner")
  wallets: [Wallet!]! @derivedFrom(field: "owner")
  devices: [Device!]! @derivedFrom(field: "owner")
  credentials: [Credential!]! @derivedFrom(field: "user")
  transactions: [Transaction!]! @derivedFrom(field: "user")
  crossChainOperations: [CrossChainOperation!]! @derivedFrom(field: "user")
  recoverysessions: [RecoverySession!]! @derivedFrom(field: "user")
  atomicOperations: [AtomicOperation!]! @derivedFrom(field: "user")
}

# Password Vault Entities
type Vault @entity {
  id: ID! # vault ID (bytes32)
  owner: User!
  
  # Vault data
  walrusCID: String
  suiTxHash: Bytes
  isActive: Boolean!
  
  # Timestamps
  createdAt: BigInt!
  lastUpdated: BigInt!
  lastAccessed: BigInt!
  accessCount: BigInt!
  
  # Related entities
  credentials: [Credential!]! @derivedFrom(field: "vault")
  blobUpdates: [VaultBlobUpdate!]! @derivedFrom(field: "vault")
  atomicUpdates: [AtomicUpdate!]! @derivedFrom(field: "vault")
}

type Credential @entity {
  id: ID! # user-vaultId-domain hash
  user: User!
  vault: Vault!
  
  # Credential data
  domain: String!
  username: String!
  
  # Timestamps
  createdAt: BigInt!
  lastUsed: BigInt!
  
  # Transaction info
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type VaultBlobUpdate @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  vault: Vault!
  
  # Update data
  newCID: String!
  suiTxHash: Bytes!
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# Wallet Vault Entities
type Wallet @entity {
  id: ID! # wallet ID (bytes32)
  owner: User!
  
  # Wallet metadata
  name: String!
  isActive: Boolean!
  
  # Chain support
  supportedChains: [Int!]!
  derivedAddresses: [DerivedAddress!]! @derivedFrom(field: "wallet")
  
  # Timestamps
  createdAt: BigInt!
  lastUsed: BigInt!
  
  # Related entities
  transactions: [Transaction!]! @derivedFrom(field: "wallet")
  balances: [ChainBalance!]! @derivedFrom(field: "wallet")
}

type DerivedAddress @entity {
  id: ID! # walletId-chainType
  wallet: Wallet!
  
  # Address data
  chainType: Int!
  address: Bytes!
  
  # Related entities
  balances: [ChainBalance!]! @derivedFrom(field: "derivedAddress")
}

type Transaction @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  wallet: Wallet!
  
  # Transaction data
  txHash: Bytes!
  chainType: Int
  signature: Bytes
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type ChainBalance @entity {
  id: ID! # user-walletId-chainType
  user: User!
  wallet: Wallet!
  derivedAddress: DerivedAddress
  
  # Balance data
  chainType: Int!
  balance: BigInt!
  totalValue: BigInt
  
  # Timestamps
  lastUpdated: BigInt!
}

# Device Registry Entities
type Device @entity {
  id: ID! # device ID (bytes32)
  owner: User!
  
  # Device data
  deviceName: String!
  deviceAddress: Bytes
  isAuthorized: Boolean!
  isRevoked: Boolean!
  
  # Timestamps
  registeredAt: BigInt!
  revokedAt: BigInt
  
  # Related entities
  accessGrants: [AccessGrant!]! @derivedFrom(field: "device")
}

type AccessGrant @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  device: Device
  
  # Access data
  resourceId: Bytes!
  grantee: Bytes!
  isRevoked: Boolean!
  
  # Timestamps
  grantedAt: BigInt!
  revokedAt: BigInt
  
  # Transaction info
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# Security Entities
type BreachAlert @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  
  # Alert data
  severity: BigInt!
  message: String!
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type SecurityAlert @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  
  # Alert data
  alertType: Int!
  description: String!
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type UnauthorizedAccess @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  
  # Access data
  unauthorized: Bytes!
  resource: String!
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# Recovery Entities
type RecoverySession @entity {
  id: ID! # recovery session ID (bytes32)
  user: User!
  
  # Recovery data
  isCompleted: Boolean!
  isCancelled: Boolean!
  requiredApprovals: Int!
  currentApprovals: Int!
  
  # Timestamps
  initiatedAt: BigInt!
  completedAt: BigInt
  cancelledAt: BigInt
  
  # Related entities
  guardianApprovals: [GuardianApproval!]! @derivedFrom(field: "recoverySession")
}

type Guardian @entity {
  id: ID! # guardian address
  user: User!
  
  # Guardian data
  guardianAddress: Bytes!
  isActive: Boolean!
  
  # Related entities
  approvals: [GuardianApproval!]! @derivedFrom(field: "guardian")
}

type GuardianApproval @entity(immutable: true) {
  id: ID! # transaction hash + log index
  recoverySession: RecoverySession!
  guardian: Guardian!
  
  # Approval data
  approvedAt: BigInt!
  
  # Transaction info
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# Cross-Chain Entities
type CrossChainOperation @entity {
  id: ID! # operation ID (bytes32)
  user: User!
  
  # Operation data
  operationId: Bytes!
  sourceChain: Int!
  targetChain: Int!
  isCompleted: Boolean!
  isSuccessful: Boolean
  
  # Timestamps
  startedAt: BigInt!
  completedAt: BigInt
  
  # Transaction info
  startTxHash: Bytes!
  completeTxHash: Bytes
}

# Atomic Operations
type AtomicOperation @entity {
  id: ID! # operation ID (bytes32)
  user: User!
  
  # Operation data
  operationType: Int!
  isCompleted: Boolean!
  isSuccessful: Boolean
  isReverted: Boolean!
  revertReason: String
  
  # Timestamps
  startedAt: BigInt!
  completedAt: BigInt
  
  # Transaction info
  startTxHash: Bytes!
  completeTxHash: Bytes
}

type AtomicUpdate @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  vault: Vault!
  
  # Update data
  suiTxHash: Bytes!
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# Generic Events for flexibility
type VaultEvent @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  
  # Event data
  flowType: Int!
  step: Int!
  success: Boolean!
  data: Bytes!
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

type GenericVaultEvent @entity(immutable: true) {
  id: ID! # transaction hash + log index
  user: User!
  
  # Event data
  eventType: Int!
  data: Bytes!
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# System Events
type SystemEvent @entity(immutable: true) {
  id: ID! # transaction hash + log index
  
  # Event data
  eventType: String! # "health_check", "emergency_shutdown", "recovery"
  admin: Bytes
  healthy: Boolean
  reason: String
  details: String
  
  # Transaction info
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# Analytics aggregations for dashboard queries
type DailyStats @entity {
  id: ID! # date in YYYY-MM-DD format
  
  # Daily metrics
  date: String!
  newUsers: BigInt!
  newVaults: BigInt!
  newWallets: BigInt!
  newDevices: BigInt!
  totalTransactions: BigInt!
  totalBreachAlerts: BigInt!
  
  # Cumulative metrics
  totalUsers: BigInt!
  totalVaults: BigInt!
  totalWallets: BigInt!
  activeUsers: BigInt!
}ûA