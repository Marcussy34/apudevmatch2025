// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class AccessGranted extends ethereum.Event {
  get params(): AccessGranted__Params {
    return new AccessGranted__Params(this);
  }
}

export class AccessGranted__Params {
  _event: AccessGranted;

  constructor(event: AccessGranted) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get resourceId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get grantee(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class AccessRevoked extends ethereum.Event {
  get params(): AccessRevoked__Params {
    return new AccessRevoked__Params(this);
  }
}

export class AccessRevoked__Params {
  _event: AccessRevoked;

  constructor(event: AccessRevoked) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get resourceId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get revokee(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class AtomicUpdateCompleted extends ethereum.Event {
  get params(): AtomicUpdateCompleted__Params {
    return new AtomicUpdateCompleted__Params(this);
  }
}

export class AtomicUpdateCompleted__Params {
  _event: AtomicUpdateCompleted;

  constructor(event: AtomicUpdateCompleted) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get vaultId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get suiTxHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class AtomicUpdateFailed extends ethereum.Event {
  get params(): AtomicUpdateFailed__Params {
    return new AtomicUpdateFailed__Params(this);
  }
}

export class AtomicUpdateFailed__Params {
  _event: AtomicUpdateFailed;

  constructor(event: AtomicUpdateFailed) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get vaultId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get reason(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class AtomicUpdateStarted extends ethereum.Event {
  get params(): AtomicUpdateStarted__Params {
    return new AtomicUpdateStarted__Params(this);
  }
}

export class AtomicUpdateStarted__Params {
  _event: AtomicUpdateStarted;

  constructor(event: AtomicUpdateStarted) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get vaultId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get walrusCID(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class ChainBalanceUpdated extends ethereum.Event {
  get params(): ChainBalanceUpdated__Params {
    return new ChainBalanceUpdated__Params(this);
  }
}

export class ChainBalanceUpdated__Params {
  _event: ChainBalanceUpdated;

  constructor(event: ChainBalanceUpdated) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get walletId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get chainType(): i32 {
    return this._event.parameters[2].value.toI32();
  }

  get newBalance(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class CrossChainOperationCompleted extends ethereum.Event {
  get params(): CrossChainOperationCompleted__Params {
    return new CrossChainOperationCompleted__Params(this);
  }
}

export class CrossChainOperationCompleted__Params {
  _event: CrossChainOperationCompleted;

  constructor(event: CrossChainOperationCompleted) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operationId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get success(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class CrossChainOperationStarted extends ethereum.Event {
  get params(): CrossChainOperationStarted__Params {
    return new CrossChainOperationStarted__Params(this);
  }
}

export class CrossChainOperationStarted__Params {
  _event: CrossChainOperationStarted;

  constructor(event: CrossChainOperationStarted) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operationId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get sourceChain(): i32 {
    return this._event.parameters[2].value.toI32();
  }

  get targetChain(): i32 {
    return this._event.parameters[3].value.toI32();
  }
}

export class DeviceAuthorized extends ethereum.Event {
  get params(): DeviceAuthorized__Params {
    return new DeviceAuthorized__Params(this);
  }
}

export class DeviceAuthorized__Params {
  _event: DeviceAuthorized;

  constructor(event: DeviceAuthorized) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get deviceId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get deviceAddress(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class DeviceRegistered extends ethereum.Event {
  get params(): DeviceRegistered__Params {
    return new DeviceRegistered__Params(this);
  }
}

export class DeviceRegistered__Params {
  _event: DeviceRegistered;

  constructor(event: DeviceRegistered) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get deviceId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get deviceName(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class DeviceRevoked extends ethereum.Event {
  get params(): DeviceRevoked__Params {
    return new DeviceRevoked__Params(this);
  }
}

export class DeviceRevoked__Params {
  _event: DeviceRevoked;

  constructor(event: DeviceRevoked) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get deviceId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get timestamp(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class EmergencyShutdown extends ethereum.Event {
  get params(): EmergencyShutdown__Params {
    return new EmergencyShutdown__Params(this);
  }
}

export class EmergencyShutdown__Params {
  _event: EmergencyShutdown;

  constructor(event: EmergencyShutdown) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get reason(): string {
    return this._event.parameters[1].value.toString();
  }

  get timestamp(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class GenericVaultEvent extends ethereum.Event {
  get params(): GenericVaultEvent__Params {
    return new GenericVaultEvent__Params(this);
  }
}

export class GenericVaultEvent__Params {
  _event: GenericVaultEvent;

  constructor(event: GenericVaultEvent) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get eventType(): i32 {
    return this._event.parameters[1].value.toI32();
  }

  get data(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class OperationRolledBack extends ethereum.Event {
  get params(): OperationRolledBack__Params {
    return new OperationRolledBack__Params(this);
  }
}

export class OperationRolledBack__Params {
  _event: OperationRolledBack;

  constructor(event: OperationRolledBack) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operationId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get reason(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class SecurityAlert extends ethereum.Event {
  get params(): SecurityAlert__Params {
    return new SecurityAlert__Params(this);
  }
}

export class SecurityAlert__Params {
  _event: SecurityAlert;

  constructor(event: SecurityAlert) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get alertType(): i32 {
    return this._event.parameters[1].value.toI32();
  }

  get description(): string {
    return this._event.parameters[2].value.toString();
  }

  get timestamp(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class SystemHealthCheck extends ethereum.Event {
  get params(): SystemHealthCheck__Params {
    return new SystemHealthCheck__Params(this);
  }
}

export class SystemHealthCheck__Params {
  _event: SystemHealthCheck;

  constructor(event: SystemHealthCheck) {
    this._event = event;
  }

  get timestamp(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get healthy(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }

  get details(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class SystemRecovery extends ethereum.Event {
  get params(): SystemRecovery__Params {
    return new SystemRecovery__Params(this);
  }
}

export class SystemRecovery__Params {
  _event: SystemRecovery;

  constructor(event: SystemRecovery) {
    this._event = event;
  }

  get admin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get timestamp(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class TransactionSigned extends ethereum.Event {
  get params(): TransactionSigned__Params {
    return new TransactionSigned__Params(this);
  }
}

export class TransactionSigned__Params {
  _event: TransactionSigned;

  constructor(event: TransactionSigned) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get walletId(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get txHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get chainType(): i32 {
    return this._event.parameters[3].value.toI32();
  }
}

export class UnauthorizedAccess extends ethereum.Event {
  get params(): UnauthorizedAccess__Params {
    return new UnauthorizedAccess__Params(this);
  }
}

export class UnauthorizedAccess__Params {
  _event: UnauthorizedAccess;

  constructor(event: UnauthorizedAccess) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get unauthorized(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get resource(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class UserFlowEvent extends ethereum.Event {
  get params(): UserFlowEvent__Params {
    return new UserFlowEvent__Params(this);
  }
}

export class UserFlowEvent__Params {
  _event: UserFlowEvent;

  constructor(event: UserFlowEvent) {
    this._event = event;
  }

  get user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get flowType(): i32 {
    return this._event.parameters[1].value.toI32();
  }

  get step(): i32 {
    return this._event.parameters[2].value.toI32();
  }

  get success(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }

  get data(): Bytes {
    return this._event.parameters[4].value.toBytes();
  }
}

export class AtomicVaultManager__defaultConfigResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: boolean;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt, value3: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    return map;
  }

  getTimeoutSeconds(): BigInt {
    return this.value0;
  }

  getMaxRetries(): BigInt {
    return this.value1;
  }

  getRetryDelaySeconds(): BigInt {
    return this.value2;
  }

  getRequireConfirmation(): boolean {
    return this.value3;
  }
}

export class AtomicVaultManager__executeAtomicUpdateResult {
  value0: string;
  value1: Bytes;

  constructor(value0: string, value1: Bytes) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromString(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    return map;
  }

  getWalrusCID(): string {
    return this.value0;
  }

  getSuiTxHash(): Bytes {
    return this.value1;
  }
}

export class AtomicVaultManager__getOperationResultOperationStruct extends ethereum.Tuple {
  get id(): Bytes {
    return this[0].toBytes();
  }

  get user(): Address {
    return this[1].toAddress();
  }

  get vaultId(): Bytes {
    return this[2].toBytes();
  }

  get walrusCID(): string {
    return this[3].toString();
  }

  get suiTxHash(): Bytes {
    return this[4].toBytes();
  }

  get status(): i32 {
    return this[5].toI32();
  }

  get startTime(): BigInt {
    return this[6].toBigInt();
  }

  get completionTime(): BigInt {
    return this[7].toBigInt();
  }
}

export class AtomicVaultManager__getOperationStatsResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt, value3: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    return map;
  }

  getTotal(): BigInt {
    return this.value0;
  }

  getSuccessful(): BigInt {
    return this.value1;
  }

  getFailed(): BigInt {
    return this.value2;
  }

  getSuccessRate(): BigInt {
    return this.value3;
  }
}

export class AtomicVaultManager__getPendingOperationsResultPendingOpsStruct extends ethereum.Tuple {
  get id(): Bytes {
    return this[0].toBytes();
  }

  get user(): Address {
    return this[1].toAddress();
  }

  get vaultId(): Bytes {
    return this[2].toBytes();
  }

  get walrusCID(): string {
    return this[3].toString();
  }

  get suiTxHash(): Bytes {
    return this[4].toBytes();
  }

  get status(): i32 {
    return this[5].toI32();
  }

  get startTime(): BigInt {
    return this[6].toBigInt();
  }

  get completionTime(): BigInt {
    return this[7].toBigInt();
  }
}

export class AtomicVaultManager__suiConfigResult {
  value0: string;
  value1: Bytes;
  value2: Bytes;
  value3: BigInt;
  value4: boolean;

  constructor(
    value0: string,
    value1: Bytes,
    value2: Bytes,
    value3: BigInt,
    value4: boolean,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromString(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    map.set("value2", ethereum.Value.fromFixedBytes(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    return map;
  }

  getRpcUrl(): string {
    return this.value0;
  }

  getPackageId(): Bytes {
    return this.value1;
  }

  getModuleId(): Bytes {
    return this.value2;
  }

  getGasLimit(): BigInt {
    return this.value3;
  }

  getIsActive(): boolean {
    return this.value4;
  }
}

export class AtomicVaultManager__walrusConfigResult {
  value0: string;
  value1: Bytes;
  value2: BigInt;
  value3: BigInt;
  value4: boolean;

  constructor(
    value0: string,
    value1: Bytes,
    value2: BigInt,
    value3: BigInt,
    value4: boolean,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromString(this.value0));
    map.set("value1", ethereum.Value.fromFixedBytes(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    return map;
  }

  getBaseUrl(): string {
    return this.value0;
  }

  getApiKey(): Bytes {
    return this.value1;
  }

  getMaxBlobSize(): BigInt {
    return this.value2;
  }

  getStorageEpochs(): BigInt {
    return this.value3;
  }

  getIsActive(): boolean {
    return this.value4;
  }
}

export class AtomicVaultManager extends ethereum.SmartContract {
  static bind(address: Address): AtomicVaultManager {
    return new AtomicVaultManager("AtomicVaultManager", address);
  }

  _updateSuiState(operationId: Bytes, vaultId: Bytes, cid: string): Bytes {
    let result = super.call(
      "_updateSuiState",
      "_updateSuiState(bytes32,bytes32,string):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(operationId),
        ethereum.Value.fromFixedBytes(vaultId),
        ethereum.Value.fromString(cid),
      ],
    );

    return result[0].toBytes();
  }

  try__updateSuiState(
    operationId: Bytes,
    vaultId: Bytes,
    cid: string,
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "_updateSuiState",
      "_updateSuiState(bytes32,bytes32,string):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(operationId),
        ethereum.Value.fromFixedBytes(vaultId),
        ethereum.Value.fromString(cid),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  _uploadToWalrus(operationId: Bytes, data: Bytes): string {
    let result = super.call(
      "_uploadToWalrus",
      "_uploadToWalrus(bytes32,bytes):(string)",
      [
        ethereum.Value.fromFixedBytes(operationId),
        ethereum.Value.fromBytes(data),
      ],
    );

    return result[0].toString();
  }

  try__uploadToWalrus(
    operationId: Bytes,
    data: Bytes,
  ): ethereum.CallResult<string> {
    let result = super.tryCall(
      "_uploadToWalrus",
      "_uploadToWalrus(bytes32,bytes):(string)",
      [
        ethereum.Value.fromFixedBytes(operationId),
        ethereum.Value.fromBytes(data),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  defaultConfig(): AtomicVaultManager__defaultConfigResult {
    let result = super.call(
      "defaultConfig",
      "defaultConfig():(uint256,uint256,uint256,bool)",
      [],
    );

    return new AtomicVaultManager__defaultConfigResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBoolean(),
    );
  }

  try_defaultConfig(): ethereum.CallResult<AtomicVaultManager__defaultConfigResult> {
    let result = super.tryCall(
      "defaultConfig",
      "defaultConfig():(uint256,uint256,uint256,bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AtomicVaultManager__defaultConfigResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBoolean(),
      ),
    );
  }

  executeAtomicUpdate(
    vaultId: Bytes,
    newVaultData: Bytes,
  ): AtomicVaultManager__executeAtomicUpdateResult {
    let result = super.call(
      "executeAtomicUpdate",
      "executeAtomicUpdate(bytes32,bytes):(string,bytes32)",
      [
        ethereum.Value.fromFixedBytes(vaultId),
        ethereum.Value.fromBytes(newVaultData),
      ],
    );

    return new AtomicVaultManager__executeAtomicUpdateResult(
      result[0].toString(),
      result[1].toBytes(),
    );
  }

  try_executeAtomicUpdate(
    vaultId: Bytes,
    newVaultData: Bytes,
  ): ethereum.CallResult<AtomicVaultManager__executeAtomicUpdateResult> {
    let result = super.tryCall(
      "executeAtomicUpdate",
      "executeAtomicUpdate(bytes32,bytes):(string,bytes32)",
      [
        ethereum.Value.fromFixedBytes(vaultId),
        ethereum.Value.fromBytes(newVaultData),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AtomicVaultManager__executeAtomicUpdateResult(
        value[0].toString(),
        value[1].toBytes(),
      ),
    );
  }

  failedOperations(): BigInt {
    let result = super.call(
      "failedOperations",
      "failedOperations():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_failedOperations(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "failedOperations",
      "failedOperations():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getOperation(
    operationId: Bytes,
  ): AtomicVaultManager__getOperationResultOperationStruct {
    let result = super.call(
      "getOperation",
      "getOperation(bytes32):((bytes32,address,bytes32,string,bytes32,uint8,uint256,uint256))",
      [ethereum.Value.fromFixedBytes(operationId)],
    );

    return changetype<AtomicVaultManager__getOperationResultOperationStruct>(
      result[0].toTuple(),
    );
  }

  try_getOperation(
    operationId: Bytes,
  ): ethereum.CallResult<AtomicVaultManager__getOperationResultOperationStruct> {
    let result = super.tryCall(
      "getOperation",
      "getOperation(bytes32):((bytes32,address,bytes32,string,bytes32,uint8,uint256,uint256))",
      [ethereum.Value.fromFixedBytes(operationId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<AtomicVaultManager__getOperationResultOperationStruct>(
        value[0].toTuple(),
      ),
    );
  }

  getOperationStats(): AtomicVaultManager__getOperationStatsResult {
    let result = super.call(
      "getOperationStats",
      "getOperationStats():(uint256,uint256,uint256,uint256)",
      [],
    );

    return new AtomicVaultManager__getOperationStatsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
    );
  }

  try_getOperationStats(): ethereum.CallResult<AtomicVaultManager__getOperationStatsResult> {
    let result = super.tryCall(
      "getOperationStats",
      "getOperationStats():(uint256,uint256,uint256,uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AtomicVaultManager__getOperationStatsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
      ),
    );
  }

  getPendingOperations(
    user: Address,
  ): Array<AtomicVaultManager__getPendingOperationsResultPendingOpsStruct> {
    let result = super.call(
      "getPendingOperations",
      "getPendingOperations(address):((bytes32,address,bytes32,string,bytes32,uint8,uint256,uint256)[])",
      [ethereum.Value.fromAddress(user)],
    );

    return result[0].toTupleArray<AtomicVaultManager__getPendingOperationsResultPendingOpsStruct>();
  }

  try_getPendingOperations(
    user: Address,
  ): ethereum.CallResult<
    Array<AtomicVaultManager__getPendingOperationsResultPendingOpsStruct>
  > {
    let result = super.tryCall(
      "getPendingOperations",
      "getPendingOperations(address):((bytes32,address,bytes32,string,bytes32,uint8,uint256,uint256)[])",
      [ethereum.Value.fromAddress(user)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<AtomicVaultManager__getPendingOperationsResultPendingOpsStruct>(),
    );
  }

  getUserOperations(user: Address): Array<Bytes> {
    let result = super.call(
      "getUserOperations",
      "getUserOperations(address):(bytes32[])",
      [ethereum.Value.fromAddress(user)],
    );

    return result[0].toBytesArray();
  }

  try_getUserOperations(user: Address): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall(
      "getUserOperations",
      "getUserOperations(address):(bytes32[])",
      [ethereum.Value.fromAddress(user)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  getVaultOperations(vaultId: Bytes): Array<Bytes> {
    let result = super.call(
      "getVaultOperations",
      "getVaultOperations(bytes32):(bytes32[])",
      [ethereum.Value.fromFixedBytes(vaultId)],
    );

    return result[0].toBytesArray();
  }

  try_getVaultOperations(vaultId: Bytes): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall(
      "getVaultOperations",
      "getVaultOperations(bytes32):(bytes32[])",
      [ethereum.Value.fromFixedBytes(vaultId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  isOperationsPaused(): boolean {
    let result = super.call(
      "isOperationsPaused",
      "isOperationsPaused():(bool)",
      [],
    );

    return result[0].toBoolean();
  }

  try_isOperationsPaused(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isOperationsPaused",
      "isOperationsPaused():(bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isPaused(): boolean {
    let result = super.call("isPaused", "isPaused():(bool)", []);

    return result[0].toBoolean();
  }

  try_isPaused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isPaused", "isPaused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  operationRetentionPeriod(): BigInt {
    let result = super.call(
      "operationRetentionPeriod",
      "operationRetentionPeriod():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_operationRetentionPeriod(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "operationRetentionPeriod",
      "operationRetentionPeriod():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  successfulOperations(): BigInt {
    let result = super.call(
      "successfulOperations",
      "successfulOperations():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_successfulOperations(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "successfulOperations",
      "successfulOperations():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  suiConfig(): AtomicVaultManager__suiConfigResult {
    let result = super.call(
      "suiConfig",
      "suiConfig():(string,bytes32,bytes32,uint256,bool)",
      [],
    );

    return new AtomicVaultManager__suiConfigResult(
      result[0].toString(),
      result[1].toBytes(),
      result[2].toBytes(),
      result[3].toBigInt(),
      result[4].toBoolean(),
    );
  }

  try_suiConfig(): ethereum.CallResult<AtomicVaultManager__suiConfigResult> {
    let result = super.tryCall(
      "suiConfig",
      "suiConfig():(string,bytes32,bytes32,uint256,bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AtomicVaultManager__suiConfigResult(
        value[0].toString(),
        value[1].toBytes(),
        value[2].toBytes(),
        value[3].toBigInt(),
        value[4].toBoolean(),
      ),
    );
  }

  totalOperations(): BigInt {
    let result = super.call(
      "totalOperations",
      "totalOperations():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_totalOperations(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalOperations",
      "totalOperations():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  verifyAtomicCompletion(
    vaultId: Bytes,
    cid: string,
    suiTxHash: Bytes,
  ): boolean {
    let result = super.call(
      "verifyAtomicCompletion",
      "verifyAtomicCompletion(bytes32,string,bytes32):(bool)",
      [
        ethereum.Value.fromFixedBytes(vaultId),
        ethereum.Value.fromString(cid),
        ethereum.Value.fromFixedBytes(suiTxHash),
      ],
    );

    return result[0].toBoolean();
  }

  try_verifyAtomicCompletion(
    vaultId: Bytes,
    cid: string,
    suiTxHash: Bytes,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "verifyAtomicCompletion",
      "verifyAtomicCompletion(bytes32,string,bytes32):(bool)",
      [
        ethereum.Value.fromFixedBytes(vaultId),
        ethereum.Value.fromString(cid),
        ethereum.Value.fromFixedBytes(suiTxHash),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  walrusConfig(): AtomicVaultManager__walrusConfigResult {
    let result = super.call(
      "walrusConfig",
      "walrusConfig():(string,bytes32,uint256,uint256,bool)",
      [],
    );

    return new AtomicVaultManager__walrusConfigResult(
      result[0].toString(),
      result[1].toBytes(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBoolean(),
    );
  }

  try_walrusConfig(): ethereum.CallResult<AtomicVaultManager__walrusConfigResult> {
    let result = super.tryCall(
      "walrusConfig",
      "walrusConfig():(string,bytes32,uint256,uint256,bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AtomicVaultManager__walrusConfigResult(
        value[0].toString(),
        value[1].toBytes(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBoolean(),
      ),
    );
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class _rollbackWalrusCall extends ethereum.Call {
  get inputs(): _rollbackWalrusCall__Inputs {
    return new _rollbackWalrusCall__Inputs(this);
  }

  get outputs(): _rollbackWalrusCall__Outputs {
    return new _rollbackWalrusCall__Outputs(this);
  }
}

export class _rollbackWalrusCall__Inputs {
  _call: _rollbackWalrusCall;

  constructor(call: _rollbackWalrusCall) {
    this._call = call;
  }

  get operationId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get cid(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class _rollbackWalrusCall__Outputs {
  _call: _rollbackWalrusCall;

  constructor(call: _rollbackWalrusCall) {
    this._call = call;
  }
}

export class CleanupExpiredOperationsCall extends ethereum.Call {
  get inputs(): CleanupExpiredOperationsCall__Inputs {
    return new CleanupExpiredOperationsCall__Inputs(this);
  }

  get outputs(): CleanupExpiredOperationsCall__Outputs {
    return new CleanupExpiredOperationsCall__Outputs(this);
  }
}

export class CleanupExpiredOperationsCall__Inputs {
  _call: CleanupExpiredOperationsCall;

  constructor(call: CleanupExpiredOperationsCall) {
    this._call = call;
  }

  get maxAge(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class CleanupExpiredOperationsCall__Outputs {
  _call: CleanupExpiredOperationsCall;

  constructor(call: CleanupExpiredOperationsCall) {
    this._call = call;
  }
}

export class EmitUserFlowEventCall extends ethereum.Call {
  get inputs(): EmitUserFlowEventCall__Inputs {
    return new EmitUserFlowEventCall__Inputs(this);
  }

  get outputs(): EmitUserFlowEventCall__Outputs {
    return new EmitUserFlowEventCall__Outputs(this);
  }
}

export class EmitUserFlowEventCall__Inputs {
  _call: EmitUserFlowEventCall;

  constructor(call: EmitUserFlowEventCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get flowType(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get step(): i32 {
    return this._call.inputValues[2].value.toI32();
  }

  get success(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class EmitUserFlowEventCall__Outputs {
  _call: EmitUserFlowEventCall;

  constructor(call: EmitUserFlowEventCall) {
    this._call = call;
  }
}

export class EmitVaultEventCall extends ethereum.Call {
  get inputs(): EmitVaultEventCall__Inputs {
    return new EmitVaultEventCall__Inputs(this);
  }

  get outputs(): EmitVaultEventCall__Outputs {
    return new EmitVaultEventCall__Outputs(this);
  }
}

export class EmitVaultEventCall__Inputs {
  _call: EmitVaultEventCall;

  constructor(call: EmitVaultEventCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get eventType(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get data(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class EmitVaultEventCall__Outputs {
  _call: EmitVaultEventCall;

  constructor(call: EmitVaultEventCall) {
    this._call = call;
  }
}

export class ExecuteAtomicUpdateCall extends ethereum.Call {
  get inputs(): ExecuteAtomicUpdateCall__Inputs {
    return new ExecuteAtomicUpdateCall__Inputs(this);
  }

  get outputs(): ExecuteAtomicUpdateCall__Outputs {
    return new ExecuteAtomicUpdateCall__Outputs(this);
  }
}

export class ExecuteAtomicUpdateCall__Inputs {
  _call: ExecuteAtomicUpdateCall;

  constructor(call: ExecuteAtomicUpdateCall) {
    this._call = call;
  }

  get vaultId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get newVaultData(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class ExecuteAtomicUpdateCall__Outputs {
  _call: ExecuteAtomicUpdateCall;

  constructor(call: ExecuteAtomicUpdateCall) {
    this._call = call;
  }

  get walrusCID(): string {
    return this._call.outputValues[0].value.toString();
  }

  get suiTxHash(): Bytes {
    return this._call.outputValues[1].value.toBytes();
  }
}

export class PauseOperationsCall extends ethereum.Call {
  get inputs(): PauseOperationsCall__Inputs {
    return new PauseOperationsCall__Inputs(this);
  }

  get outputs(): PauseOperationsCall__Outputs {
    return new PauseOperationsCall__Outputs(this);
  }
}

export class PauseOperationsCall__Inputs {
  _call: PauseOperationsCall;

  constructor(call: PauseOperationsCall) {
    this._call = call;
  }
}

export class PauseOperationsCall__Outputs {
  _call: PauseOperationsCall;

  constructor(call: PauseOperationsCall) {
    this._call = call;
  }
}

export class ResumeOperationsCall extends ethereum.Call {
  get inputs(): ResumeOperationsCall__Inputs {
    return new ResumeOperationsCall__Inputs(this);
  }

  get outputs(): ResumeOperationsCall__Outputs {
    return new ResumeOperationsCall__Outputs(this);
  }
}

export class ResumeOperationsCall__Inputs {
  _call: ResumeOperationsCall;

  constructor(call: ResumeOperationsCall) {
    this._call = call;
  }
}

export class ResumeOperationsCall__Outputs {
  _call: ResumeOperationsCall;

  constructor(call: ResumeOperationsCall) {
    this._call = call;
  }
}

export class RollbackFailedUpdateCall extends ethereum.Call {
  get inputs(): RollbackFailedUpdateCall__Inputs {
    return new RollbackFailedUpdateCall__Inputs(this);
  }

  get outputs(): RollbackFailedUpdateCall__Outputs {
    return new RollbackFailedUpdateCall__Outputs(this);
  }
}

export class RollbackFailedUpdateCall__Inputs {
  _call: RollbackFailedUpdateCall;

  constructor(call: RollbackFailedUpdateCall) {
    this._call = call;
  }

  get vaultId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get failedCID(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class RollbackFailedUpdateCall__Outputs {
  _call: RollbackFailedUpdateCall;

  constructor(call: RollbackFailedUpdateCall) {
    this._call = call;
  }
}

export class UpdateOperationConfigCall extends ethereum.Call {
  get inputs(): UpdateOperationConfigCall__Inputs {
    return new UpdateOperationConfigCall__Inputs(this);
  }

  get outputs(): UpdateOperationConfigCall__Outputs {
    return new UpdateOperationConfigCall__Outputs(this);
  }
}

export class UpdateOperationConfigCall__Inputs {
  _call: UpdateOperationConfigCall;

  constructor(call: UpdateOperationConfigCall) {
    this._call = call;
  }

  get timeoutSeconds(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get maxRetries(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get retryDelaySeconds(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get requireConfirmation(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class UpdateOperationConfigCall__Outputs {
  _call: UpdateOperationConfigCall;

  constructor(call: UpdateOperationConfigCall) {
    this._call = call;
  }
}

export class UpdateSuiConfigCall extends ethereum.Call {
  get inputs(): UpdateSuiConfigCall__Inputs {
    return new UpdateSuiConfigCall__Inputs(this);
  }

  get outputs(): UpdateSuiConfigCall__Outputs {
    return new UpdateSuiConfigCall__Outputs(this);
  }
}

export class UpdateSuiConfigCall__Inputs {
  _call: UpdateSuiConfigCall;

  constructor(call: UpdateSuiConfigCall) {
    this._call = call;
  }

  get rpcUrl(): string {
    return this._call.inputValues[0].value.toString();
  }

  get packageId(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get moduleId(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get gasLimit(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class UpdateSuiConfigCall__Outputs {
  _call: UpdateSuiConfigCall;

  constructor(call: UpdateSuiConfigCall) {
    this._call = call;
  }
}

export class UpdateWalrusConfigCall extends ethereum.Call {
  get inputs(): UpdateWalrusConfigCall__Inputs {
    return new UpdateWalrusConfigCall__Inputs(this);
  }

  get outputs(): UpdateWalrusConfigCall__Outputs {
    return new UpdateWalrusConfigCall__Outputs(this);
  }
}

export class UpdateWalrusConfigCall__Inputs {
  _call: UpdateWalrusConfigCall;

  constructor(call: UpdateWalrusConfigCall) {
    this._call = call;
  }

  get baseUrl(): string {
    return this._call.inputValues[0].value.toString();
  }

  get apiKey(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get maxBlobSize(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get storageEpochs(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class UpdateWalrusConfigCall__Outputs {
  _call: UpdateWalrusConfigCall;

  constructor(call: UpdateWalrusConfigCall) {
    this._call = call;
  }
}
