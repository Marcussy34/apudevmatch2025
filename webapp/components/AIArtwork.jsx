import React, { useEffect, useMemo, useState } from "react";
import { useCurrentAccount } from "@mysten/dapp-kit";
import { Transaction } from "@mysten/sui/transactions";

function AIArtwork({ summaryMarkdown, stats, signAndExecute }) {
    const [status, setStatus] = useState("idle");
    const [error, setError] = useState(null);
    const [imageDataUrl, setImageDataUrl] = useState(null);
    const account = useCurrentAccount();

    const totals = useMemo(() => {
        const totalChecked =
            stats?.total_checked ??
            parseInt(
                (summaryMarkdown.match(/Total\s+(?:Accounts\s+)?Checked:\s*(\d+)/i) || [])[1] ||
                "0"
            );
        const totalPwned =
            stats?.total_pwned ??
            parseInt(
                (summaryMarkdown.match(/Total\s+(?:Accounts\s+)?Pwned:\s*(\d+)/i) || [])[1] ||
                "0"
            );
        return { totalChecked, totalPwned };
    }, [stats, summaryMarkdown]);

    const generateWithGemini = async () => {
        const { totalChecked, totalPwned } = totals;
        const ratio = totalChecked > 0 ? totalPwned / totalChecked : 0;
        const mood =
            ratio === 0
                ? "victory, calm, secure"
                : ratio < 0.4
                    ? "caution, improving, vigilant"
                    : "urgent, breach, high-alert";
        const title =
            ratio === 0
                ? "Fortress Secure"
                : ratio < 0.4
                    ? "Shielded but Vulnerable"
                    : "Breach Warning";

        const prompt = `Generate a cyberpunk-style digital art illustration representing "${title}". Create a futuristic security dashboard visualization showing ${totalPwned} breached accounts out of ${totalChecked} total accounts. Theme: ${mood}. Style: neon colors, dark background, abstract geometric shapes representing data security, glowing elements, high contrast, holographic interface elements. No text or logos. Square aspect ratio.`;

        const geminiApiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
        if (!geminiApiKey) {
            throw new Error("Missing NEXT_PUBLIC_GEMINI_API_KEY in environment variables");
        }

        const response = await fetch(
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent",
            {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "x-goog-api-key": geminiApiKey,
                },
                body: JSON.stringify({
                    contents: [
                        {
                            parts: [{ text: prompt }],
                        },
                    ],
                    generationConfig: {
                        temperature: 0.8,
                        maxOutputTokens: 1024,
                        responseModalities: ["TEXT", "IMAGE"],
                    },
                }),
            }
        );

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Gemini API failed: ${response.status} - ${errorText}`);
        }

        const data = await response.json();

        if (data.candidates?.[0]?.content?.parts) {
            for (const part of data.candidates[0].content.parts) {
                if (part.inlineData?.data) {
                    const base64Data = part.inlineData.data;
                    const mimeType = part.inlineData.mimeType || "image/png";
                    return `data:${mimeType};base64,${base64Data}`;
                }
                if (part.text) {
                    // no-op: helpful logs could be added here
                }
            }
        }

        throw new Error("No image generated by Gemini");
    };

    const generateEnhancedVisualization = (aiDescription) => {
        const { totalChecked, totalPwned } = totals;
        const ratio = totalChecked > 0 ? totalPwned / totalChecked : 0;

        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        const bgGradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 300);
        bgGradient.addColorStop(0, "#1a1a2e");
        bgGradient.addColorStop(0.5, "#16213e");
        bgGradient.addColorStop(1, "#0f0f1a");
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, 512, 512);

        const hasUrgent = aiDescription.toLowerCase().includes("urgent") || ratio > 0.4;
        const hasSecure = aiDescription.toLowerCase().includes("secure") || ratio === 0;

        ctx.strokeStyle = hasUrgent ? "#ff4444" : hasSecure ? "#00ff88" : "#4488ff";
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.3;
        for (let i = 0; i < 512; i += 32) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, 512);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(512, i);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;

        const centerX = 256;
        const centerY = 256;
        const maxRadius = 150;

        const secureRadius = maxRadius * (1 - ratio);
        if (secureRadius > 0) {
            const secureGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, secureRadius);
            secureGradient.addColorStop(0, "rgba(0, 255, 136, 0.8)");
            secureGradient.addColorStop(0.7, "rgba(0, 255, 136, 0.3)");
            secureGradient.addColorStop(1, "rgba(0, 255, 136, 0.1)");
            ctx.fillStyle = secureGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, secureRadius, 0, 2 * Math.PI);
            ctx.fill();
        }

        if (ratio > 0) {
            const breachedGradient = ctx.createRadialGradient(centerX, centerY, secureRadius, centerX, centerY, maxRadius);
            breachedGradient.addColorStop(0, "rgba(255, 68, 68, 0.8)");
            breachedGradient.addColorStop(1, "rgba(255, 68, 68, 0.1)");
            ctx.fillStyle = breachedGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, 2 * Math.PI);
            ctx.fill();
        }

        ctx.shadowColor = ratio === 0 ? "#00ff88" : ratio < 0.4 ? "#ffff00" : "#ff4444";
        ctx.shadowBlur = 20;
        ctx.strokeStyle = ratio === 0 ? "#00ff88" : ratio < 0.4 ? "#ffff00" : "#ff4444";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - 40);
        ctx.lineTo(centerX - 30, centerY - 15);
        ctx.lineTo(centerX - 30, centerY + 20);
        ctx.lineTo(centerX, centerY + 40);
        ctx.lineTo(centerX + 30, centerY + 20);
        ctx.lineTo(centerX + 30, centerY - 15);
        ctx.closePath();
        ctx.stroke();
        ctx.shadowBlur = 0;

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 18px monospace";
        ctx.textAlign = "center";
        ctx.shadowColor = "#000000";
        ctx.shadowBlur = 4;
        ctx.fillText(`${totalChecked} ACCOUNTS CHECKED`, centerX, centerY + 80);
        ctx.fillText(`${totalPwned} BREACHED`, centerX, centerY + 105);

        const riskText = ratio === 0 ? "SECURE" : ratio < 0.4 ? "CAUTION" : "HIGH RISK";
        ctx.font = "bold 24px monospace";
        ctx.fillStyle = ratio === 0 ? "#00ff88" : ratio < 0.4 ? "#ffff00" : "#ff4444";
        ctx.fillText(riskText, centerX, centerY - 60);

        return canvas.toDataURL("image/jpeg", 0.8);
    };

    const generate = async () => {
        setError(null);
        setStatus("generating");

        try {
            try {
                const aiImage = await generateWithGemini();
                setImageDataUrl(aiImage);
                setStatus("ready");
                return;
            } catch (geminiError) {
                setError(
                    `Gemini AI unavailable: ${geminiError?.message || "Unknown error"}. Using enhanced local visualization.`
                );
                const enhancedImage = generateEnhancedVisualization("");
                setImageDataUrl(enhancedImage);
                setStatus("ready");
            }
        } catch (e) {
            setError(e?.message || "Image generation failed");
            setStatus("error");
        }
    };

    useEffect(() => {
        generate();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const mintNft = async () => {
        if (!account) return setError("Connect wallet first");
        if (!imageDataUrl) return;

        setStatus("generating");
        setError(null);

        try {
            const name = "Grand Warden Security NFT";
            const desc = `Security snapshot: ${totals.totalPwned} of ${totals.totalChecked} accounts breached. Generated on ${new Date().toISOString()}.`;

            let imageUrl;
            if (imageDataUrl.startsWith("data:image") && imageDataUrl.includes("base64")) {
                const ratio = totals.totalChecked > 0 ? totals.totalPwned / totals.totalChecked : 0;
                const riskLevel = ratio === 0 ? "secure" : ratio < 0.4 ? "caution" : "breach";
                const timestamp = Date.now();
                imageUrl = `ipfs://QmGeminiAI${riskLevel}${totals.totalChecked}x${totals.totalPwned}t${timestamp}`;
            } else {
                const ratio = totals.totalChecked > 0 ? totals.totalPwned / totals.totalChecked : 0;
                const riskLevel = ratio === 0 ? "secure" : ratio < 0.4 ? "caution" : "breach";
                imageUrl = `ipfs://QmSecurityViz${riskLevel}${totals.totalChecked}x${totals.totalPwned}`;
            }

            const packageId = process.env.NEXT_PUBLIC_SECURITY_NFT_PACKAGE_ID || "0x2";

            const nameBytes = new TextEncoder().encode(name);
            const descBytes = new TextEncoder().encode(desc);
            const imageUrlBytes = new TextEncoder().encode(imageUrl);

            if (nameBytes.length + descBytes.length + imageUrlBytes.length > 15000) {
                throw new Error("NFT metadata too large for SUI transaction");
            }

            const tx = new Transaction();
            tx.moveCall({
                target: `${packageId}::security_nft::mint_security_nft`,
                arguments: [
                    tx.pure("vector<u8>", Array.from(nameBytes)),
                    tx.pure("vector<u8>", Array.from(descBytes)),
                    tx.pure("vector<u8>", Array.from(imageUrlBytes)),
                    tx.pure.u64(totals.totalChecked),
                    tx.pure.u64(totals.totalPwned),
                ],
            });

            const res = await signAndExecute({
                transaction: tx,
                options: { showEffects: true, showObjectChanges: true, showEvents: true },
            });

            let nftObjectId = null;
            if (res.objectChanges) {
                const createdObject = res.objectChanges.find(
                    (change) => change.type === "created" && change.objectType?.includes("security_nft::SecurityNFT")
                );
                if (createdObject) {
                    nftObjectId = createdObject.objectId;
                }
            }

            setStatus("ready");
            const message = nftObjectId
                ? `ðŸŽ‰ Security NFT minted successfully!\n\nObject ID: ${nftObjectId}\n\nYour unique security snapshot is now an NFT with ${totals.totalChecked} accounts checked and ${totals.totalPwned} breached.`
                : `ðŸŽ‰ Security NFT minted successfully!\n\nTransaction: ${res.digest}\n\nCheck your wallet for the new NFT!`;
            alert(message);
        } catch (e) {
            setError(e?.message || "NFT minting failed");
            setStatus("ready");
        }
    };

    return (
        <div className="bg-cyber-900/50 border border-cyber-700 rounded-lg p-6 shadow-lg">
            <div className="flex items-center justify-between mb-3">
                <h4 className="text-cyber-100 font-semibold">AI Security Artwork</h4>
                {status === "generating" && (
                    <span className="text-cyber-400 text-sm">Generating with AIâ€¦</span>
                )}
            </div>
            <p className="text-cyber-400 text-xs mb-3">
                {imageDataUrl?.includes("base64")
                    ? "ðŸ¤– AI-generated cyberpunk artwork by Gemini 2.0"
                    : "ðŸŽ¨ Enhanced local visualization (Gemini fallback)"}
            </p>
            {error && <div className="text-red-400 text-sm mb-3">{error}</div>}
            {imageDataUrl ? (
                <div className="space-y-3">
                    <img
                        src={imageDataUrl}
                        alt="Security visualization"
                        className="w-full rounded-md border border-cyber-700"
                    />
                    <div className="flex gap-2">
                        <button
                            onClick={mintNft}
                            disabled={status === "generating" || !account}
                            className={`cyber-button px-4 py-2 ${status === "generating" ? "opacity-50 cursor-not-allowed" : ""
                                } ${!account ? "opacity-50 cursor-not-allowed" : ""}`}
                        >
                            {status === "generating" ? "Minting NFT..." : "Mint Security NFT"}
                        </button>
                        {!account && (
                            <p className="text-cyber-400 text-xs self-center">
                                Connect wallet to mint NFT
                            </p>
                        )}
                    </div>
                </div>
            ) : (
                <div className="h-64 w-full rounded-md bg-cyber-800/40 border border-cyber-700 animate-pulse flex items-center justify-center">
                    <span className="text-cyber-400">Generating AI artwork...</span>
                </div>
            )}
        </div>
    );
}

export default AIArtwork;


